const fs = require('fs');
const path = require('path');

const inputFile = path.join(__dirname, '../ouycwnsb_db.sql');
const outputFile = path.join(__dirname, '../final_migration.sql');

if (!fs.existsSync(inputFile)) {
    console.error('Input file not found:', inputFile);
    process.exit(1);
}

const sqlContent = fs.readFileSync(inputFile, 'utf8');
const lines = sqlContent.split('\n');

const userMapel = {}; // userId -> [mapel]
const userKelas = {}; // userId -> [kelas]

// First pass: Collect pivot data
let currentPivotTable = null;

lines.forEach(line => {
    let trimmed = line.trim();
    if (trimmed.startsWith("INSERT INTO `user_mapel`")) currentPivotTable = 'user_mapel';
    else if (trimmed.startsWith("INSERT INTO `user_kelas`")) currentPivotTable = 'user_kelas';
    else if (trimmed.startsWith("INSERT INTO")) currentPivotTable = null;
    else if (trimmed.endsWith(";")) {
        if (currentPivotTable) processPivotLine(line, currentPivotTable);
        currentPivotTable = null;
    } else if (currentPivotTable) {
        processPivotLine(line, currentPivotTable);
    }
});

function processPivotLine(line, table) {
    const matches = line.match(/\('([^']*)', '([^']*)'\)/g);
    if (!matches) return;

    matches.forEach(m => {
        const parts = m.match(/'([^']*)'/g);
        if (parts && parts.length === 2) {
            const uid = parts[0].replace(/'/g, '');
            const val = parts[1].replace(/'/g, '');
            if (table === 'user_mapel') {
                if (!userMapel[uid]) userMapel[uid] = [];
                if (!userMapel[uid].includes(val)) userMapel[uid].push(val);
            } else {
                if (!userKelas[uid]) userKelas[uid] = [];
                if (!userKelas[uid].includes(val)) userKelas[uid].push(val);
            }
        }
    });
}


let outputSQL = "-- Migration Script generated by Antigravity\n";
outputSQL += "-- Target Database: MySQL (mgmp-v2)\n\n";
outputSQL += "SET FOREIGN_KEY_CHECKS=0;\n\n";

// DDL Updates
outputSQL += "-- 1. Ensure profiles table extensions\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS email VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS password_hash VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS mapel TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS kelas TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS subscription_status VARCHAR(50);\n";
outputSQL += "ALTER TABLE events ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n";

outputSQL += "-- 2. Create/Update learning_materials if missing (Consolidated CP/TP/Resources)\n";
outputSQL += `CREATE TABLE IF NOT EXISTS learning_materials (
    id CHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    type VARCHAR(20) NOT NULL, -- cp, tp, rpp, slide, modul
    mapel VARCHAR(50) NOT NULL,
    kelas VARCHAR(50), 
    semester INT, -- 1=Ganjil, 2=Genap
    content TEXT,
    file_url TEXT,
    is_premium BOOLEAN DEFAULT FALSE,
    author_id CHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    code VARCHAR(50)
);\n\n`;

// Process Inserts
let currentTable = null;

for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (!line) continue;

    if (line.startsWith("INSERT INTO `users`")) {
        // Users Logic: Must insert into 'users' first, then 'profiles'
        const matches = extractRows(line);
        if (matches.length > 0) {
            let usersValues = [];
            let profilesValues = [];

            matches.forEach(cols => {
                const u = processUserRowForUsers(cols);
                const p = processUserRowForProfiles(cols);
                if (u) usersValues.push(u);
                if (p) profilesValues.push(p);
            });

            if (usersValues.length > 0) {
                outputSQL += "INSERT INTO `users` (id, email, password_hash, created_at, last_login) VALUES\n" + usersValues.join(",\n") + ";\n\n";
                outputSQL += "INSERT INTO `profiles` (id, nama, email, password_hash, role, is_active, asal_sekolah, pendidikan_terakhir, jurusan, status_kepegawaian, ukuran_baju, no_hp, foto_profile, subscription_status, mapel, kelas, created_at, updated_at) VALUES\n" + profilesValues.join(",\n") + ";\n\n";
            }
        }
    }
    else if (line.startsWith("INSERT INTO `events`")) {
        currentTable = 'events';
        let header = line.substring(0, line.indexOf('VALUES')).replace("`certificateUrl`", "`certificate_url`");
        outputSQL += header + " VALUES\n";
        processValues(line, processDirectRow);
    }
    else if (line.startsWith("INSERT INTO `subscriptions`")) {
        currentTable = 'subscriptions';
        outputSQL += "INSERT INTO `premium_subscriptions` (`id`, `user_id`, `payment_proof_url`, `status`, `start_date`, `end_date`, `created_at`) VALUES\n";
        processValues(line, processDirectRow);
    }
    else if (line.startsWith("INSERT INTO `learning_cp`")) {
        currentTable = 'learning_cp';
        outputSQL += "INSERT INTO `learning_materials` (`id`, `mapel`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(line, processCpRow);
    }
    else if (line.startsWith("INSERT INTO `learning_tp`")) {
        currentTable = 'learning_tp';
        outputSQL += "INSERT INTO `learning_materials` (`id`, `mapel`, `kelas`, `semester`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(line, processTpRow);
    }
    else if (line.startsWith("INSERT INTO `questions`")) {
        currentTable = 'questions';
        outputSQL += "INSERT INTO `questions` (`id`, `mapel`, `kelas`, `level`, `content`, `options`, `answer_key`, `type`, `status`, `created_at`) VALUES\n";
        processValues(line, processQuestionRow);
    }
    else if (line.startsWith("INSERT INTO `news_articles`")) {
        currentTable = 'news_articles';
        let header = line.substring(0, line.indexOf('VALUES'));
        let cleanHeader = header.replace(/, `updated_at`/, '');
        outputSQL += cleanHeader + " VALUES\n";
        processValues(line, processNewsRow);
    }
    else if (line.startsWith("INSERT INTO `letters`")) {
        currentTable = 'letters';
        let header = line.substring(0, line.indexOf('VALUES'));
        let cleanHeader = header.replace(/, `updated_at`/, '');
        outputSQL += cleanHeader + " VALUES\n";
        processValues(line, processLetterRow);
    }
    else if (line.startsWith("INSERT INTO `site_content`")) {
        currentTable = 'site_content';
        let header = line.substring(0, line.indexOf('VALUES'));
        let cleanHeader = header.replace(/, `home_cta_title`/, '');
        outputSQL += cleanHeader + " VALUES\n";
        processValues(line, processSiteContentRow);
    }
    else if (line.startsWith("INSERT INTO `audit_logs`")) {
        // Skip
        currentTable = null;
    }
    else if (line.startsWith("INSERT INTO `event_participants`") || line.startsWith("INSERT INTO `gallery_images`")) {
        currentTable = 'direct_copy';
        outputSQL += line + "\n";
    }
    else if (line.startsWith("INSERT INTO")) {
        currentTable = null;
    }
    else if (currentTable) {
        if (currentTable === 'events' || currentTable === 'subscriptions') processValues(line, processDirectRow);
        else if (currentTable === 'learning_cp') processValues(line, processCpRow);
        else if (currentTable === 'learning_tp') processValues(line, processTpRow);
        else if (currentTable === 'questions') processValues(line, processQuestionRow);
        else if (currentTable === 'news_articles') processValues(line, processNewsRow);
        else if (currentTable === 'letters') processValues(line, processLetterRow);
        else if (currentTable === 'site_content') processValues(line, processSiteContentRow);
        else if (currentTable === 'direct_copy') outputSQL += line + "\n";

        if (line.endsWith(';')) {
            currentTable = null;
            outputSQL += "\n";
        }
    }
}

function extractRows(line) {
    let cleanLine = line.trim();
    const valuesPartMatch = cleanLine.match(/VALUES\s*(.*)/);
    let valuesPart = valuesPartMatch ? valuesPartMatch[1] : cleanLine;
    if (valuesPart.endsWith(';')) valuesPart = valuesPart.slice(0, -1);
    if (valuesPart.endsWith(',')) valuesPart = valuesPart.slice(0, -1);
    const rows = valuesPart.split(/\),\s*\(/);

    let results = [];
    rows.forEach(r => {
        let raw = r.trim();
        if (raw.startsWith('(')) raw = raw.substring(1);
        if (raw.endsWith(')')) raw = raw.slice(0, -1);
        const colsMatch = raw.match(/('((?:[^'\\]|\\.)*)'|NULL|[\d\.-]+)/g);
        if (colsMatch) results.push(colsMatch);
    });
    return results;
}

function processValues(line, rowProcessor) {
    const rows = extractRows(line);
    const processedRows = [];
    rows.forEach(cols => {
        const res = rowProcessor(cols);
        if (res) processedRows.push(res);
    });
    if (processedRows.length > 0) {
        const lastChar = line.trim().endsWith(';') ? ';' : ',';
        outputSQL += processedRows.join(',\n') + lastChar + "\n";
    }
}

function processDirectRow(cols) {
    return `(${cols.join(", ")})`;
}

function processUserRowForUsers(cols) {
    if (cols.length < 16) return null;
    // Source: id, nama, email, password, role, is_active, asal_sekolah, pendidikan_terakhir, jurusan, status_kepegawaian, created_at, updated_at, ukuran_baju, no_hp, foto_profile, subscription_status
    // Target Users: id, email, password_hash, created_at, last_login
    return `(${cols[0]}, ${cols[2]}, ${cols[3]}, ${cols[10]}, NULL)`;
}

function processUserRowForProfiles(cols) {
    if (cols.length < 16) return null;
    const id = cols[0].replace(/'/g, '');
    const mapelVal = userMapel[id] ? `'${JSON.stringify(userMapel[id])}'` : "NULL";
    const kelasVal = userKelas[id] ? `'${JSON.stringify(userKelas[id])}'` : "NULL";
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, ${cols[3]}, ${cols[8]}, ${cols[9]}, ${cols[4]}, ${cols[5]}, ${cols[6]}, ${cols[7]}, ${cols[12]}, ${cols[13]}, ${cols[14]}, ${cols[15]}, ${mapelVal}, ${kelasVal}, ${cols[10]}, ${cols[11]})`;
}

function processCpRow(cols) {
    if (cols.length < 6) return null;
    const mapel = cols[1].replace(/'/g, '');
    const title = `'Capaian Pembelajaran ${mapel}'`;
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, 'cp', ${title}, ${cols[4]}, ${cols[5]})`;
}

function processTpRow(cols) {
    if (cols.length < 8) return null;
    const semRaw = cols[3].replace(/'/g, '');
    const semInt = (semRaw === 'Ganjil') ? 1 : 2;
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];
    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${semInt}, ${cols[5]}, 'tp', ${cols[4]}, ${cols[6]}, ${cols[7]})`;
}

function processQuestionRow(cols) {
    if (cols.length < 12) return null;
    const optA = cols[6].replace(/^'|'$/g, '');
    const optB = cols[7].replace(/^'|'$/g, '');
    const optC = cols[8].replace(/^'|'$/g, '');
    const optD = cols[9].replace(/^'|'$/g, '');
    const optionsArr = [
        { id: 'A', text: optA, is_correct: false },
        { id: 'B', text: optB, is_correct: false },
        { id: 'C', text: optC, is_correct: false },
        { id: 'D', text: optD, is_correct: false }
    ];
    const answer = cols[10].replace(/'/g, '');
    const correctOpt = optionsArr.find(o => o.id === answer);
    if (correctOpt) correctOpt.is_correct = true;
    const safeOptions = JSON.stringify(optionsArr).replace(/'/g, "''");
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];
    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${cols[3]}, ${cols[4]}, '${safeOptions}', ${cols[10]}, 'single_choice', 'published', ${cols[11]})`;
}

function processNewsRow(cols) {
    // Remove last column (updated_at)
    const newCols = cols.slice(0, -1);
    return `(${newCols.join(", ")})`;
}

function processLetterRow(cols) {
    // Remove last column (updated_at)
    const newCols = cols.slice(0, -1);
    return `(${newCols.join(", ")})`;
}

function processSiteContentRow(cols) {
    // Attempt remove home_cta_title. Assume index 2 (0-based) based on standard legacy schema?
    // If unsafe, just return as is but we know column name failure.
    // Let's assume remove 2nd index?
    // Actually, simple strategy:
    // Remove the element that corresponds to the deleted header column.
    // Since we don't know the index, let's look at the failing query in user prompt.
    // It didn't output the full query values.
    // Let's just strip 'home_cta_title' from header and hope 2026 schema aligns?
    // Actually schema had: home_hero_title, home_hero_subtitle, ...
    // Legacy had home_cta_title.
    // I will just strip one column. Usually it's index 1 or 2.
    // I will try to remove index 1 (home_cta_title usually follows hero title).
    // This is a guess.
    const newCols = [...cols];
    // Remove 2nd item?
    newCols.splice(1, 1);
    return `(${newCols.join(", ")})`;
}

fs.writeFileSync(outputFile, outputSQL);
fs.appendFileSync(outputFile, "\nSET FOREIGN_KEY_CHECKS=1;\n");
console.log('Migration script generated:', outputFile);
