const fs = require('fs');
const path = require('path');

const inputFile = path.join(__dirname, '../ouycwnsb_db.sql');
const outputFile = path.join(__dirname, '../final_migration.sql');

if (!fs.existsSync(inputFile)) {
    console.error('Input file not found:', inputFile);
    process.exit(1);
}

const sqlContent = fs.readFileSync(inputFile, 'utf8');
const lines = sqlContent.split('\n');

const userMapel = {}; // userId -> [mapel]
const userKelas = {}; // userId -> [kelas]

// First pass: Collect pivot data
let currentPivotTable = null;

lines.forEach(line => {
    let trimmed = line.trim();
    if (trimmed.startsWith("INSERT INTO `user_mapel`")) currentPivotTable = 'user_mapel';
    else if (trimmed.startsWith("INSERT INTO `user_kelas`")) currentPivotTable = 'user_kelas';
    else if (trimmed.startsWith("INSERT INTO")) currentPivotTable = null;
    else if (trimmed.endsWith(";")) {
        if (currentPivotTable) processPivotLine(line, currentPivotTable);
        currentPivotTable = null;
    } else if (currentPivotTable) {
        processPivotLine(line, currentPivotTable);
    }
});

function processPivotLine(line, table) {
    const matches = line.match(/\('([^']*)', '([^']*)'\)/g);
    if (!matches) return;

    matches.forEach(m => {
        const parts = m.match(/'([^']*)'/g);
        if (parts && parts.length === 2) {
            const uid = parts[0].replace(/'/g, '');
            const val = parts[1].replace(/'/g, '');
            if (table === 'user_mapel') {
                if (!userMapel[uid]) userMapel[uid] = [];
                if (!userMapel[uid].includes(val)) userMapel[uid].push(val);
            } else {
                // Store clean kelas name if possible, or source
                // Source: 7, 8, 9. Target: Kelas VII, Kelas VIII, Kelas IX?
                // But pivot might use full names. Let's trust source for now.
                if (!userKelas[uid]) userKelas[uid] = [];
                if (!userKelas[uid].includes(val)) userKelas[uid].push(val);
            }
        }
    });
}


let outputSQL = "-- Migration Script generated by Antigravity\n";
outputSQL += "-- Target Database: MySQL (mgmp-v2)\n\n";
outputSQL += "SET FOREIGN_KEY_CHECKS=0;\n\n";

// DDL Updates
outputSQL += "-- 1. Ensure profiles table extensions\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS email VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS password_hash VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS mapel TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS kelas TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS subscription_status VARCHAR(50);\n";
outputSQL += "ALTER TABLE events ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n";

outputSQL += "-- 2. Create/Update learning_materials if missing (Consolidated CP/TP/Resources)\n";
outputSQL += `CREATE TABLE IF NOT EXISTS learning_materials (
    id CHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    type VARCHAR(20) NOT NULL, -- cp, tp, rpp, slide, modul
    mapel VARCHAR(50) NOT NULL,
    kelas VARCHAR(50), 
    semester INT, -- 1=Ganjil, 2=Genap
    content TEXT,
    file_url TEXT,
    is_premium BOOLEAN DEFAULT FALSE,
    author_id CHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    code VARCHAR(50)
);\n\n`;

// Process Inserts
let currentTable = null;

for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (!line) continue;

    if (line.startsWith("INSERT INTO `users`")) {
        currentTable = 'users';
        outputSQL += `INSERT INTO \`profiles\` (id, nama, email, password_hash, role, is_active, asal_sekolah, pendidikan_terakhir, jurusan, status_kepegawaian, ukuran_baju, no_hp, foto_profile, subscription_status, mapel, kelas, created_at, updated_at) VALUES\n`;
        processValues(line, processUserRow);
    }
    else if (line.startsWith("INSERT INTO `events`")) {
        currentTable = 'events';
        let header = line.substring(0, line.indexOf('VALUES')).replace("`certificateUrl`", "`certificate_url`");
        outputSQL += header + " VALUES\n";
        processValues(line, (row) => row); // Pass-through
    }
    else if (line.startsWith("INSERT INTO `subscriptions`")) {
        currentTable = 'subscriptions';
        outputSQL += "INSERT INTO `premium_subscriptions` (`id`, `user_id`, `payment_proof_url`, `status`, `start_date`, `end_date`, `created_at`) VALUES\n";
        processValues(line, (row) => row);
    }
    else if (line.startsWith("INSERT INTO `learning_cp`")) {
        currentTable = 'learning_cp';
        outputSQL += "INSERT INTO `learning_materials` (`id`, `mapel`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(line, processCpRow);
    }
    else if (line.startsWith("INSERT INTO `learning_tp`")) {
        currentTable = 'learning_tp';
        // TP Target map: id, mapel, kelas, semester, content(tujuan), type='tp', title=materi, author_id, created_at
        outputSQL += "INSERT INTO `learning_materials` (`id`, `mapel`, `kelas`, `semester`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(line, processTpRow);
    }
    else if (line.startsWith("INSERT INTO `questions`")) {
        currentTable = 'questions';
        // Questions Target: id, mapel, kelas, level, content, options, answer_key, type='single_choice', status='published', created_at
        // Source: id, mapel, kelas, level, question_text, question_image, option_a..d, correct_answer, created_at
        outputSQL += "INSERT INTO `questions` (`id`, `mapel`, `kelas`, `level`, `content`, `options`, `answer_key`, `type`, `status`, `created_at`) VALUES\n";
        processValues(line, processQuestionRow);
    }
    else if (line.startsWith("INSERT INTO `news_articles`")) {
        currentTable = 'news_articles';
        let header = line.substring(0, line.indexOf('VALUES'));
        // Remove updated_at from header if target doesn't support it? 20260110 schema said no updated_at.
        // Let's assume schema has it OR we remove it. 
        // To be safe against 20260110 schema, I will remove `updated_at`.
        let cleanHeader = header.replace(/, `updated_at`/, '');
        outputSQL += cleanHeader + " VALUES\n";
        processValues(line, processNewsRow);
    }
    else if (line.startsWith("INSERT INTO `gallery_images`") || line.startsWith("INSERT INTO `letters`") || line.startsWith("INSERT INTO `event_participants`") || line.startsWith("INSERT INTO `site_content`") || line.startsWith("INSERT INTO `audit_logs`")) {
        currentTable = 'direct_copy';
        outputSQL += line + "\n";
    }
    else if (line.startsWith("INSERT INTO")) {
        currentTable = null;
    }
    else if (currentTable) {
        if (currentTable === 'users') processValues(line, processUserRow);
        else if (currentTable === 'learning_cp') processValues(line, processCpRow);
        else if (currentTable === 'learning_tp') processValues(line, processTpRow);
        else if (currentTable === 'questions') processValues(line, processQuestionRow);
        else if (currentTable === 'news_articles') processValues(line, processNewsRow);
        else if (currentTable === 'direct_copy') outputSQL += line + "\n";
        else if (currentTable === 'events' || currentTable === 'subscriptions') processValues(line, (row) => row);

        if (line.endsWith(';')) {
            currentTable = null;
            outputSQL += "\n";
        }
    }
}

function processValues(line, rowProcessor) {
    let cleanLine = line.trim();
    const valuesPartMatch = cleanLine.match(/VALUES\s*(.*)/);
    let valuesPart = valuesPartMatch ? valuesPartMatch[1] : cleanLine;

    if (valuesPart.endsWith(';')) valuesPart = valuesPart.slice(0, -1);
    if (valuesPart.endsWith(',')) valuesPart = valuesPart.slice(0, -1);

    // Split rows: simple split by `), (` is risky but standard for mysqldump
    // We used state machine before but regex `\),\s*\(` works 99% of time on dumps
    const rows = valuesPart.split(/\),\s*\(/);

    const processedRows = [];

    rows.forEach((r, idx) => {
        let raw = r.trim();
        if (raw.startsWith('(')) raw = raw.substring(1);
        if (raw.endsWith(')')) raw = raw.slice(0, -1);

        // Parse columns
        // This regex captures 'string' OR NULL OR numbers
        const colsMatch = raw.match(/('((?:[^'\\]|\\.)*)'|NULL|[\d\.-]+)/g);
        if (!colsMatch) return;

        const res = rowProcessor(colsMatch);
        if (res) processedRows.push(res);
    });

    if (processedRows.length > 0) {
        const lastChar = line.trim().endsWith(';') ? ';' : ',';
        outputSQL += processedRows.join(',\n') + lastChar + "\n";
    }
}

function processUserRow(cols) {
    if (cols.length < 16) return null;
    const id = cols[0].replace(/'/g, '');
    const mapelVal = userMapel[id] ? `'${JSON.stringify(userMapel[id])}'` : "NULL";
    const kelasVal = userKelas[id] ? `'${JSON.stringify(userKelas[id])}'` : "NULL";
    // cols mapping: users -> profiles
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, ${cols[3]}, ${cols[8]}, ${cols[9]}, ${cols[4]}, ${cols[5]}, ${cols[6]}, ${cols[7]}, ${cols[12]}, ${cols[13]}, ${cols[14]}, ${cols[15]}, ${mapelVal}, ${kelasVal}, ${cols[10]}, ${cols[11]})`;
}

function processCpRow(cols) {
    // Legacy CP: id, mapel, content, materi, updated_by, updated_at
    // New Learning: id, mapel, content, type='cp', title, author_id, created_at
    // title = "Capaian Pembelajaran " + mapel
    if (cols.length < 6) return null;
    const mapel = cols[1].replace(/'/g, '');
    const title = `'Capaian Pembelajaran ${mapel}'`;
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, 'cp', ${title}, ${cols[4]}, ${cols[5]})`;
}

function processTpRow(cols) {
    // Legacy TP: id, mapel, kelas, semester, materi, tujuan, created_by, created_at
    // New Learning: id, mapel, kelas, semester, content(tujuan), type='tp', title(materi), author_id, created_at
    if (cols.length < 8) return null;

    // Map Semester 'Ganjil'->1, 'Genap'->2
    const semRaw = cols[3].replace(/'/g, '');
    const semInt = (semRaw === 'Ganjil') ? 1 : 2;

    // Map Kelas '7'->'Kelas VII'
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];

    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${semInt}, ${cols[5]}, 'tp', ${cols[4]}, ${cols[6]}, ${cols[7]})`;
}

function processQuestionRow(cols) {
    // Legacy Q: id, mapel, kelas, level, question_text, question_image, opt_a, opt_b, opt_c, opt_d, answer, created_at (12 cols)
    // New Q: id, mapel, kelas, level, content, options, answer_key, type, status, created_at
    // options JSON
    if (cols.length < 12) return null;

    const optA = cols[6].replace(/^'|'$/g, '');
    const optB = cols[7].replace(/^'|'$/g, '');
    const optC = cols[8].replace(/^'|'$/g, '');
    const optD = cols[9].replace(/^'|'$/g, '');

    const optionsArr = [
        { id: 'A', text: optA, is_correct: false },
        { id: 'B', text: optB, is_correct: false },
        { id: 'C', text: optC, is_correct: false },
        { id: 'D', text: optD, is_correct: false }
    ];

    const answer = cols[10].replace(/'/g, '');
    const correctOpt = optionsArr.find(o => o.id === answer);
    if (correctOpt) correctOpt.is_correct = true;

    const optionsJson = `'${JSON.stringify(optionsArr)}'`; // MySQL safe? Needs escaping for SQL string context
    // Actually, dumping JSON into SQL string is tricky with quotes.
    // We should buffer hex or carefully escape. Dumps use simple escaping.
    // Simplifying: remove single quotes from text inside options to avoid breakage

    const safeOptions = JSON.stringify(optionsArr).replace(/'/g, "''"); // Escape single quotes for SQL

    // Map Kelas
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];

    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${cols[3]}, ${cols[4]}, '${safeOptions}', ${cols[10]}, 'single_choice', 'published', ${cols[11]})`;
}

function processNewsRow(cols) {
    // Legacy: id, title, content, author_id, image_url, created_at, updated_at
    // Target: id, title, content, author_id, image_url, created_at
    if (cols.length < 7) return null;
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, ${cols[3]}, ${cols[4]}, ${cols[5]})`;
}

fs.writeFileSync(outputFile, outputSQL);
fs.appendFileSync(outputFile, "\nSET FOREIGN_KEY_CHECKS=1;\n");
console.log('Migration script generated:', outputFile);
