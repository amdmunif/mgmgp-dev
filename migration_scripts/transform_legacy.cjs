const fs = require('fs');
const path = require('path');

const inputFile = path.join(__dirname, '../ouycwnsb_db.sql');
const outputFile = path.join(__dirname, '../backend/migration_final.sql');

if (!fs.existsSync(inputFile)) {
    console.error('Input file not found:', inputFile);
    process.exit(1);
}

const sqlContent = fs.readFileSync(inputFile, 'utf8');
const lines = sqlContent.split('\n');

const userMapel = {}; // userId -> [mapel]
const userKelas = {}; // userId -> [kelas]

// First pass: Collect pivot data
let currentPivotTable = null;

lines.forEach(line => {
    let trimmed = line.trim();
    if (trimmed.startsWith("INSERT INTO `user_mapel`")) currentPivotTable = 'user_mapel';
    else if (trimmed.startsWith("INSERT INTO `user_kelas`")) currentPivotTable = 'user_kelas';
    else if (trimmed.startsWith("INSERT INTO")) currentPivotTable = null;
    else if (trimmed.endsWith(";")) {
        if (currentPivotTable) processPivotLine(line, currentPivotTable);
        currentPivotTable = null;
    } else if (currentPivotTable) {
        processPivotLine(line, currentPivotTable);
    }
});

function processPivotLine(line, table) {
    const matches = line.match(/\('([^']*)', '([^']*)'\)/g);
    if (!matches) return;

    matches.forEach(m => {
        const parts = m.match(/'([^']*)'/g);
        if (parts && parts.length === 2) {
            const uid = parts[0].replace(/'/g, '');
            const val = parts[1].replace(/'/g, '');
            if (table === 'user_mapel') {
                if (!userMapel[uid]) userMapel[uid] = [];
                if (!userMapel[uid].includes(val)) userMapel[uid].push(val);
            } else {
                if (!userKelas[uid]) userKelas[uid] = [];
                if (!userKelas[uid].includes(val)) userKelas[uid].push(val);
            }
        }
    });
}


let outputSQL = "-- Migration Script generated by Antigravity\n";
outputSQL += "-- Target Database: MySQL (mgmp-v2)\n\n";
outputSQL += "SET FOREIGN_KEY_CHECKS=0;\n\n";

// DDL Updates
outputSQL += "-- 1. Ensure profiles table extensions\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS email VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS password_hash VARCHAR(255);\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS mapel TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS kelas TEXT; -- JSON\n";
outputSQL += "ALTER TABLE profiles ADD COLUMN IF NOT EXISTS subscription_status VARCHAR(50);\n";
outputSQL += "ALTER TABLE events ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n\n";

outputSQL += "-- 2. Create/Update learning_materials if missing (Consolidated CP/TP/Resources)\n";
outputSQL += `CREATE TABLE IF NOT EXISTS learning_materials (
    id CHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    type VARCHAR(20) NOT NULL, -- cp, tp, rpp, slide, modul
    mapel VARCHAR(50) NOT NULL,
    kelas VARCHAR(50), 
    semester INT, -- 1=Ganjil, 2=Genap
    content TEXT,
    file_url TEXT,
    is_premium BOOLEAN DEFAULT FALSE,
    author_id CHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    code VARCHAR(50)
);\n\n`;

// Process Inserts
let currentTable = null;

// Process Inserts
let currentStatementBuffer = "";

for (let i = 0; i < lines.length; i++) {
    let line = lines[i]; // Preserve original line content including spaces
    let trimmed = line.trim();
    if (!trimmed && currentStatementBuffer === "") continue;

    if (currentStatementBuffer === "") {
        currentStatementBuffer = line;
    } else {
        currentStatementBuffer += "\n" + line;
    }

    // Check for end of statement
    if (trimmed.endsWith(';')) {
        processFullStatement(currentStatementBuffer);
        currentStatementBuffer = "";
    }
}



function processFullStatement(statement) {
    // Find the INSERT statement within the buffer (ignoring comments)
    const match = statement.match(/INSERT INTO `([^`]+)`/);
    if (!match) return;

    const tableName = match[1];
    const sqlStart = match.index;
    const cleanStmt = statement.substring(sqlStart); // Start from INSERT

    if (tableName === 'users') {
        const matches = extractRows(cleanStmt);
        if (matches.length > 0) {
            let usersValues = [];
            let profilesValues = [];

            matches.forEach(cols => {
                const u = processUserRowForUsers(cols);
                const p = processUserRowForProfiles(cols);
                if (u) usersValues.push(u);
                if (p) profilesValues.push(p);
            });

            if (usersValues.length > 0) {
                outputSQL += "INSERT IGNORE INTO `users` (id, email, password_hash, created_at, last_login) VALUES\n" + usersValues.join(",\n") + ";\n\n";
                outputSQL += "INSERT IGNORE INTO `profiles` (id, nama, email, password_hash, role, is_active, asal_sekolah, pendidikan_terakhir, jurusan, status_kepegawaian, ukuran_baju, no_hp, foto_profile, subscription_status, mapel, kelas, created_at, updated_at) VALUES\n" + profilesValues.join(",\n") + ";\n\n";
            }
        }
    }
    else if (tableName === 'events') {
        let header = cleanStmt.substring(0, cleanStmt.indexOf('VALUES')).replace("`certificateUrl`", "`certificate_url`");
        outputSQL += header.replace("INSERT INTO", "INSERT IGNORE INTO") + " VALUES\n";
        processValues(cleanStmt, processDirectRow);
    }
    else if (tableName === 'subscriptions') {
        outputSQL += "INSERT IGNORE INTO `premium_subscriptions` (`id`, `user_id`, `payment_proof_url`, `status`, `start_date`, `end_date`, `created_at`) VALUES\n";
        processValues(cleanStmt, processDirectRow);
    }
    else if (tableName === 'learning_cp') {
        outputSQL += "INSERT IGNORE INTO `learning_materials` (`id`, `mapel`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(cleanStmt, processCpRow);
    }
    else if (tableName === 'learning_tp') {
        outputSQL += "INSERT IGNORE INTO `learning_materials` (`id`, `mapel`, `kelas`, `semester`, `content`, `type`, `title`, `author_id`, `created_at`) VALUES\n";
        processValues(cleanStmt, processTpRow);
    }
    else if (tableName === 'questions') {
        outputSQL += "INSERT IGNORE INTO `questions` (`id`, `mapel`, `kelas`, `level`, `content`, `options`, `answer_key`, `type`, `status`, `created_at`) VALUES\n";
        processValues(cleanStmt, processQuestionRow);
    }
    else if (tableName === 'news_articles') {
        let header = cleanStmt.substring(0, cleanStmt.indexOf('VALUES'));
        let cleanHeader = header.replace(/, `updated_at`/, '').replace("INSERT INTO", "INSERT IGNORE INTO");
        outputSQL += cleanHeader + " VALUES\n";
        processValues(cleanStmt, processNewsRow);
    }
    else if (tableName === 'letters') {
        let header = cleanStmt.substring(0, cleanStmt.indexOf('VALUES'));
        let cleanHeader = header.replace(/, `updated_at`/, '').replace("INSERT INTO", "INSERT IGNORE INTO");
        outputSQL += cleanHeader + " VALUES\n";
        processValues(cleanStmt, processLetterRow);
    }
    else if (tableName === 'site_content') {
        let header = cleanStmt.substring(0, cleanStmt.indexOf('VALUES'));
        let cleanHeader = header.replace("INSERT INTO", "INSERT IGNORE INTO")
            .replace(/, `home_cta_title`/, '')
            .replace(/, `home_cta_subtitle`/, '');
        outputSQL += cleanHeader + " VALUES\n";
        processValues(cleanStmt, processSiteContentRow);
    }
    else if (tableName === 'event_participants' || tableName === 'gallery_images') {
        outputSQL += cleanStmt.replace("INSERT INTO", "INSERT IGNORE INTO") + "\n";
    }
}

function extractRows(line) {
    let cleanLine = line.trim();
    // Use s flag for dotAll to match newlines
    const valuesPartMatch = cleanLine.match(/VALUES\s*(.*)/s);
    let valuesPart = valuesPartMatch ? valuesPartMatch[1] : cleanLine;
    if (valuesPart.endsWith(';')) valuesPart = valuesPart.slice(0, -1);

    // Split by tuple separator ), (
    // We need to be careful not to split inside strings.
    // The previous split algorithm was simplistic.
    // Better: Match all tuples (....) including newlines

    const rows = valuesPart.split(/\),\s*\(/);
    // This split works if ")," isn't inside a string.
    // With SQL values, parentheses inside strings are possible.
    // But typically mysqldump escapes them or uses extended inserts safely.
    // Given the previous code used this splitting, we keep it but rely on the fact that
    // valuesPart now contains the full multi-line content.

    let results = [];
    rows.forEach(r => {
        let raw = r.trim();
        if (raw.startsWith('(')) raw = raw.substring(1);
        if (raw.endsWith(')')) raw = raw.slice(0, -1);
        // Regex to match columns, handling escaped quotes and newlines
        const colsMatch = raw.match(/('((?:[^'\\]|\\.)*)'|NULL|[\d\.-]+)/g);
        if (colsMatch) results.push(colsMatch);
    });
    return results;
}

function processValues(line, rowProcessor) {
    const rows = extractRows(line);
    const processedRows = [];
    rows.forEach(cols => {
        const res = rowProcessor(cols);
        if (res) processedRows.push(res);
    });
    if (processedRows.length > 0) {
        const lastChar = line.trim().endsWith(';') ? ';' : ',';
        outputSQL += processedRows.join(',\n') + lastChar + "\n";
    }
}

function processDirectRow(cols) {
    return `(${cols.join(", ")})`;
}

function processUserRowForUsers(cols) {
    if (cols.length < 16) return null;
    // Source: id, nama, email, password, role, is_active, asal_sekolah, pendidikan_terakhir, jurusan, status_kepegawaian, created_at, updated_at, ukuran_baju, no_hp, foto_profile, subscription_status
    // Target Users: id, email, password_hash, created_at, last_login
    return `(${cols[0]}, ${cols[2]}, ${cols[3]}, ${cols[10]}, NULL)`;
}

function processUserRowForProfiles(cols) {
    if (cols.length < 16) return null;
    const id = cols[0].replace(/'/g, '');
    const mapelVal = userMapel[id] ? `'${JSON.stringify(userMapel[id])}'` : "NULL";
    const kelasVal = userKelas[id] ? `'${JSON.stringify(userKelas[id])}'` : "NULL";
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, ${cols[3]}, ${cols[8]}, ${cols[9]}, ${cols[4]}, ${cols[5]}, ${cols[6]}, ${cols[7]}, ${cols[12]}, ${cols[13]}, ${cols[14]}, ${cols[15]}, ${mapelVal}, ${kelasVal}, ${cols[10]}, ${cols[11]})`;
}

function processCpRow(cols) {
    if (cols.length < 6) return null;
    const mapel = cols[1].replace(/'/g, '');
    const title = `'Capaian Pembelajaran ${mapel}'`;
    return `(${cols[0]}, ${cols[1]}, ${cols[2]}, 'cp', ${title}, ${cols[4]}, ${cols[5]})`;
}

function processTpRow(cols) {
    if (cols.length < 8) return null;
    const semRaw = cols[3].replace(/'/g, '');
    const semInt = (semRaw === 'Ganjil') ? 1 : 2;
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];
    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${semInt}, ${cols[5]}, 'tp', ${cols[4]}, ${cols[6]}, ${cols[7]})`;
}

function processQuestionRow(cols) {
    if (cols.length < 12) return null;
    const optA = cols[6].replace(/^'|'$/g, '');
    const optB = cols[7].replace(/^'|'$/g, '');
    const optC = cols[8].replace(/^'|'$/g, '');
    const optD = cols[9].replace(/^'|'$/g, '');
    const optionsArr = [
        { id: 'A', text: optA, is_correct: false },
        { id: 'B', text: optB, is_correct: false },
        { id: 'C', text: optC, is_correct: false },
        { id: 'D', text: optD, is_correct: false }
    ];
    const answer = cols[10].replace(/'/g, '');
    const correctOpt = optionsArr.find(o => o.id === answer);
    if (correctOpt) correctOpt.is_correct = true;
    const safeOptions = JSON.stringify(optionsArr).replace(/'/g, "''");
    let kelasRaw = cols[2].replace(/'/g, '');
    let kelasMap = { '7': 'Kelas VII', '8': 'Kelas VIII', '9': 'Kelas IX' };
    let kelasFormatted = kelasMap[kelasRaw] ? `'${kelasMap[kelasRaw]}'` : cols[2];
    return `(${cols[0]}, ${cols[1]}, ${kelasFormatted}, ${cols[3]}, ${cols[4]}, '${safeOptions}', ${cols[10]}, 'single_choice', 'published', ${cols[11]})`;
}

function processNewsRow(cols) {
    // Remove last column (updated_at)
    const newCols = cols.slice(0, -1);
    return `(${newCols.join(", ")})`;
}

function processLetterRow(cols) {
    // Remove last column (updated_at)
    const newCols = cols.slice(0, -1);
    return `(${newCols.join(", ")})`;
}

function processSiteContentRow(cols) {
    // Attempt remove home_cta_title (idx 1?) and home_cta_subtitle (idx 2?)
    // Safer approach: Remove index 1 and 2.
    const newCols = [...cols];
    // Remove 2 items from index 1.
    newCols.splice(1, 2);
    return `(${newCols.join(", ")})`;
}

fs.writeFileSync(outputFile, outputSQL);
fs.appendFileSync(outputFile, "\nSET FOREIGN_KEY_CHECKS=1;\n");
console.log('Migration script generated:', outputFile);
